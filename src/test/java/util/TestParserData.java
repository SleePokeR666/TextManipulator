package util;

public interface TestParserData {

	String positiveSentence1 = "Сложение (+), вычитание и унарный минус (-), " +
			"умножение (*), деление (/) и присвоение (=) " +
			"работают одинаково фактически во всех языках программирования.";

	String positiveSentence2 = "Исключениями являются =, ==, !=, которые могут быть применены " +
			"к объектам (и создают немало затруднений).";

	String positiveSentence3 = "Язык Java создавался на основе C++, " +
			"поэтому большинство этих операторов и конструкций знакомы программистам на C и C++.";

	String positiveSentence4 = "Нижняя граница равна 0, но для предотвращения возможного " +
			"деления на 0 результат смещается на 1.";

	String positiveSentence5 = "Выражение System.out.println(n1 == n2) выведет результат " +
			"логического сравнения, содержащегося в скобках.";

	String positiveSentence6 = "Программа генерирует различные типы случайных чисел, " +
			"вызывая соответствующие методы объекта Random: nextInt() и nextFloat() " +
			"(также можно использовать nextLong() и nextDouble()).";

	String positiveParagraph = "Оператор инкремента объясняет происхождение названия языка C++; " +
			"подразумевается «шаг вперед по сравнению с C». В одной из первых речей, " +
			"посвященных Java, Билл Джой (один из его создателей) сказал, что «Java=C++--» " +
			"(«Си плюс плюс минус минус»). Он имел в виду, что Java — это C++, из которого " +
			"убрано все, что затрудняет программирование, и поэтому язык стал гораздо проще. " +
			"Продвигаясь вперед, вы увидите, что отдельные аспекты языка, конечно, проще, " +
			"и все же Java не настолько проще C++.";

	String positiveText = "</spoiler> Последний символ обозначает тип записанного литерала. Прописная или строчная буква L определяет тип long (впрочем, строчная l может создать проблемы, потому что она похожа на цифру 1); прописная или строчная F соответствует типу float, а заглавная или строчная D подразумевает тип double.\n" +
			"\n" +
			"Шестнадцатеричное представление (основание 16) работает со всеми встроенными типами данных и обозначается префиксом 0x или 0X с последующим числовым значением из цифр 0-9 и букв a-f, прописных или строчных. Если при определении переменной задается значение, превосходящее максимально для нее возможное (независимо от числовой формы), компилятор сообщит вам об ошибке. В программе указаны максимальные значения для типов char, byte и short. При выходе за эти границы компилятор автоматически сделает значение типом int и сообщит вам, что для присвоения понадобится сужающее приведение.\n" +
			"\n" +
			"Восьмеричное представление (по основанию 8) обозначается начальным нулем в записи числа, состоящего из цифр 0 - 7. Для литеральной записи чисел в двоичном представлении в Java, C и C++ поддержки нет. Впрочем, при работе с шестнадцатеричныыми и восьмеричными числами часто требуется получить двоичное представление результата. Задача легко решается методами static toBinaryString() классов Integer и Long.\n" +
			"\n" +
			"\n" +
			"Экспоненциальная запись\n" +
			"Экспоненциальные значения записываются, по-моему, очень неудачно: 1.39e-47f. В науке и инженерном деле символом е обозначается основание натурального логарифма, равное примерно 2.718. (Более точное значение этой величины можно получить из свойства Math.E.)\n" +
			"\n" +
			"Оно используется в экспоненциальных выражениях, таких как 1.39 * е exp47, что фактически значит 1.39 * 2.718 exp47. Однако во время изобретения языка FORTRAN было решено, что е будет обозначать «десять в степени», что достаточно странно, поскольку FORTRAN разрабатывался для науки и техники и можно было предположить, что его создатели обратят внимание на подобную неоднозначность.\n" +
			"\n" +
			"Так или иначе, этот обычай был перенят в C, C++, а затем перешел в Java. Таким образом, если вы привыкли видеть в е основание натурального логарифма, вам придется каждый раз делать преобразование в уме: если вы увидели в Java выражение 1.39e-43f, на самом деле оно значит 1.39 * 10 exp43.\n" +
			"\n" +
			"Если компилятор может определить тип автоматически, наличие завершающего суффикса типа не обязательно. В записи\n" +
			"\n" +
			" long n3 = 200;\n" +
			"не существует никаких неясностей, и поэтому использование символа L после значения 200 было бы излишним. Однако в записи\n" +
			"\n" +
			"float f4 = 1e-43f; // десять в степени\n" +
			"компилятор обычно трактует экспоненциальные числа как double. Без завершающего символа f он сообщит вам об ошибке и необходимости использования приведения для преобразования double к типу float.\n" +
			"\n" +
			"Поразрядные операторы\n" +
			"Поразрядные логические операторы\n" +
			"Поразрядные операторы манипулируют отдельными битами в целочисленных примитивных типах данных. Результат определяется действиями булевой алгебры с соответствующими битами двух операндов. Эти битовые операторы происходят от низкоуровневой направленности языка C, где часто приходится напрямую работать с оборудованием и устанавливать биты в аппаратных регистрах. Java изначально разрабатывался для управления телевизионными приставками, поэтому эта низкоуровневая ориентация все еще была нужна. Впрочем, вам вряд ли придется часто использовать эти операторы.\n" +
			"\n" +
			"Поразрядный оператор И ( & ) заносит 1 в выходной бит, если оба входных бита были равны 1; в противном случае результат равен 0.\n" +
			"Поразрядный оператор ИЛИ ( | ) заносит 1 в выходной бит, если хотя бы один из битов операндов был равен 1; результат равен 0 только в том случае, если оба бита операндов были нулевыми.\n" +
			"Оператор ИСКЛЮЧАЮЩЕЕ ИЛИ, XOR, ( ^ ) имеет результатом единицу тогда, когда один из входных битов был единицей, но не оба вместе.\n" +
			"Поразрядный оператор НЕ ( ~ ), также называемый оператором двоичного дополнения, является унарным оператором, то есть имеет только один операнд. Поразрядное НЕ производит бит, «противоположный» исходному — если входящий бит является нулем, то в результирующем бите окажется единица, если входящий бит — единица, получится ноль.\n" +
			"Поразрядные операторы и логические операторы записываются с помощью одних и тех же символов, поэтому полезно запомнить мнемоническое правило: так как биты «маленькие», в поразрядных операторах используется всего один символ.\n" +
			"\n" +
			"Поразрядные операторы могут комбинироваться со знаком равенства =, чтобы совместить операцию и присвоение: &=, |= и ^= являются допустимыми сочетаниями. (Так как ~ является унарным оператором, он не может использоваться вместе со знаком \"=\".)\n" +
			"\n" +
			"Тип boolean трактуется как однобитовый, поэтому операции с ним выглядят по-другому. Вы вправе выполнить поразрядные И, ИЛИ и ИСКЛЮЧАЮЩЕЕ ИЛИ, но НЕ использовать запрещено (видимо, чтобы предотвратить путаницу с логическим НЕ). Для типа boolean поразрядные операторы производят тот же эффект, что и логические, за одним исключением — они не поддерживают ускоренного вычисления.\n" +
			"\n" +
			"Кроме того, в число поразрядных операторов для boolean входит оператор ИСКЛЮЧАЮЩЕЕ ИЛИ, отсутствующий в списке логических операторов. Для булевых типов не разрешается использование операторов сдвига, описанных в следующем разделе.\n" +
			"\n" +
			"Операторы сдвига\n" +
			"Операторы сдвига также манипулируют битами и используются только с примитивными целочисленными типами. Оператор сдвига влево (<<) сдвигает влево операнд, находящийся слева от оператора, на количество битов, указанное после оператора. Оператор сдвига вправо (>>) сдвигает вправо операнд, находящийся слева от оператора, на количество битов, указанное после оператора. При сдвиге вправо используется заполнение знаком: при положительном значении новые биты заполняются нулями, а при отрицательном — единицами.\n" +
			"\n" +
			"В Java также поддерживается беззнаковый сдвиг вправо (>>>), использующий заполнение нулями: независимо от знака старшие биты заполняются нулями. Такой оператор не имеет аналогов в C и C++.\n" +
			"\n" +
			"Если сдвигаемое значение относится к типу char, byte или short, эти типы приводятся к int перед выполнением сдвига, и результат также получится int. При этом используется только пять младших битов с «правой» стороны. Таким образом, нельзя сдвинуть битов больше, чем вообще существует для целого числа int. Если вы проводите операции с числами long, то получите результаты типа long. При этом будет задействовано только шесть младших битов с «правой» стороны, что предотвращает использование излишнего числа битов.\n" +
			"\n" +
			"Сдвиги можно совмещать со знаком равенства (<<=, или >>=, или >>>=). Именующее выражение заменяется им же, но с проведенными над ним операциями сдвига. Однако при этом возникает проблема с оператором беззнакового правого сдвига, совмещенного с присвоением. При использовании его с типом byte или short вы не получите правильных результатов. Вместо этого они сначала будут преобразованы к типу int и сдвинуты вправо, а затем обрезаны при возвращении к исходному типу, и результатом станет -1. Следующий пример демонстрирует это:";
}
